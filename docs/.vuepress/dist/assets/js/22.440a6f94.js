(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{181:function(t,r,a){"use strict";a.r(r);var s=a(0),e=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"判断一个对象是不是数组-共有几种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断一个对象是不是数组-共有几种方式","aria-hidden":"true"}},[t._v("#")]),t._v(" 判断一个对象是不是数组?共有几种方式?")]),t._v(" "),a("p",[t._v("解析: typeof: 只能区分原始类型的函数"),a("br"),t._v("\n并不能进一步细致区分出对象的类型名;")]),t._v(" "),a("p",[t._v("方法如下:")]),t._v(" "),a("h2",{attrs:{id:"判断爹-原型对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断爹-原型对象","aria-hidden":"true"}},[t._v("#")]),t._v(" 判断爹(原型对象)")]),t._v(" "),a("p",[t._v("var bool=父对象.isPrototypeOf(子对象);")]),t._v(" "),a("h2",{attrs:{id:"判断妈-构造函数-之一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断妈-构造函数-之一","aria-hidden":"true"}},[t._v("#")]),t._v(" 判断妈(构造函数) 之一")]),t._v(" "),a("p",[t._v("obj.constructor===构造函数;\n问题: constructor 是隐藏属性,并不推荐使用;")]),t._v(" "),a("h2",{attrs:{id:"判断妈-构造函数-之二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#判断妈-构造函数-之二","aria-hidden":"true"}},[t._v("#")]),t._v(" 判断妈(构造函数) 之二")]),t._v(" "),a("p",[t._v("obj instanceof 构造函数;\n强调: 以上两种方式都不仅检查直接的父类型,也检查是不是整个原型链的")]),t._v(" "),a("h2",{attrs:{id:"验dna"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#验dna","aria-hidden":"true"}},[t._v("#")]),t._v(" 验DNA")]),t._v(" "),a("p",[t._v("原理: 在每个对象内都有一个隐藏属性 Class"),a("br"),t._v("\n属性: class保存了对象创建时的最初类型;不会随着继承关系的改变而改变;"),a("br"),t._v("\n思路: 只有Object.prototype 中最原始 toString() 才能输出 class 属性\n返回值: [object class属性值];  //Object Array Date")]),t._v(" "),a("p",[t._v("易错点: 使用子对象.toString(), 容易被父对象中的toString()所重写")]),t._v(" "),a("p",[t._v("解决: 用call 强行调用Object.prototype中的 toString();\nObject.prototype.toString.call(obj);")]),t._v(" "),a("h2",{attrs:{id:"isarray"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isarray","aria-hidden":"true"}},[t._v("#")]),t._v(" isArray()")]),t._v(" "),a("p",[t._v("作用: 专门判断任何一个对象是不是Array类型\n语法: var bool=Array.isArray(obj);\n** 第四种 第五种方法都是严格验证  **")]),t._v(" "),a("h1",{attrs:{id:"鄙视二-何时函数定义在原型对象中-何时将函数直接定义在构造函数上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#鄙视二-何时函数定义在原型对象中-何时将函数直接定义在构造函数上","aria-hidden":"true"}},[t._v("#")]),t._v(" 鄙视二 何时函数定义在原型对象中,何时将函数直接定义在构造函数上?")]),t._v(" "),a("p",[t._v("答: 如果只允许指定类型的子对象才能使用的函数,必须放在原型对象中,继承使用\n如果希望不限制类型,所有对象都使用的函数,可以直接放在构造函数上:\n比如 : sort()    push()   isArray()\nArray.prototype.sort();\nArray.prototype.push();\nArray.isArray();")])])}],!1,null,null,null);r.default=e.exports}}]);